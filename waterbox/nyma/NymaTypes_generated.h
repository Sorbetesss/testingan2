// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_NYMATYPES_NYMATYPES_H_
#define FLATBUFFERS_GENERATED_NYMATYPES_NYMATYPES_H_

#include "flatbuffers/flatbuffers.h"

namespace NymaTypes {

struct EnumValue;
struct EnumValueBuilder;
struct EnumValueT;

struct Setting;
struct SettingBuilder;
struct SettingT;

struct Settings;
struct SettingsBuilder;
struct SettingsT;

enum SettingType {
  /// (signed), int8, int16, int32, int64(saved as)
  SettingType_Int = 0,
  /// uint8, uint16, uint32, uint64(saved as)
  SettingType_Uint = 1,
  /// 0 or 1
  SettingType_Bool = 2,
  /// float64
  SettingType_Float = 3,
  SettingType_String = 4,
  /// string value from a list of potential strings
  SettingType_Enum = 5,
  /// TODO: How do these work
  SettingType_MultiEnum = 6,
  /// Shouldn't see any of these
  SettingType_Alias = 7,
  SettingType_MIN = SettingType_Int,
  SettingType_MAX = SettingType_Alias
};

inline const SettingType (&EnumValuesSettingType())[8] {
  static const SettingType values[] = {
    SettingType_Int,
    SettingType_Uint,
    SettingType_Bool,
    SettingType_Float,
    SettingType_String,
    SettingType_Enum,
    SettingType_MultiEnum,
    SettingType_Alias
  };
  return values;
}

inline const char * const *EnumNamesSettingType() {
  static const char * const names[9] = {
    "Int",
    "Uint",
    "Bool",
    "Float",
    "String",
    "Enum",
    "MultiEnum",
    "Alias",
    nullptr
  };
  return names;
}

inline const char *EnumNameSettingType(SettingType e) {
  if (flatbuffers::IsOutRange(e, SettingType_Int, SettingType_Alias)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesSettingType()[index];
}

enum SettingsFlags {
  /// TODO(cats)
  SettingsFlags_Input = 256,
  SettingsFlags_Sound = 512,
  SettingsFlags_Video = 1024,
  /// User-configurable physical->virtual button/axes and hotkey mappings(driver-side code category mainly).
  SettingsFlags_InputMapping = 2048,
  SettingsFlags_Path = 4096,
  /// If the setting affects emulation from the point of view of the emulated program
  SettingsFlags_EmuState = 131072,
  /// If it's safe for an untrusted source to modify it, probably only used in conjunction with MDFNST_EX_EMU_STATE and network play
  SettingsFlags_UntrustedSafe = 262144,
  /// Suppress documentation generation for this setting.
  SettingsFlags_SuppressDoc = 524288,
  /// Auto-generated common template setting(like nes.xscale, pce.xscale, vb.xscale, nes.enable, pce.enable, vb.enable)
  SettingsFlags_CommonTemplate = 1048576,
  /// Don't save setting in settings file.
  SettingsFlags_NonPersistent = 2097152,
  /// TODO(in progress)
  SettingsFlags_RequiresReload = 16777216,
  SettingsFlags_RequiresRestart = 33554432,
  SettingsFlags_NONE = 0,
  SettingsFlags_ANY = 54402816
};

inline const SettingsFlags (&EnumValuesSettingsFlags())[12] {
  static const SettingsFlags values[] = {
    SettingsFlags_Input,
    SettingsFlags_Sound,
    SettingsFlags_Video,
    SettingsFlags_InputMapping,
    SettingsFlags_Path,
    SettingsFlags_EmuState,
    SettingsFlags_UntrustedSafe,
    SettingsFlags_SuppressDoc,
    SettingsFlags_CommonTemplate,
    SettingsFlags_NonPersistent,
    SettingsFlags_RequiresReload,
    SettingsFlags_RequiresRestart
  };
  return values;
}

inline const char *EnumNameSettingsFlags(SettingsFlags e) {
  switch (e) {
    case SettingsFlags_Input: return "Input";
    case SettingsFlags_Sound: return "Sound";
    case SettingsFlags_Video: return "Video";
    case SettingsFlags_InputMapping: return "InputMapping";
    case SettingsFlags_Path: return "Path";
    case SettingsFlags_EmuState: return "EmuState";
    case SettingsFlags_UntrustedSafe: return "UntrustedSafe";
    case SettingsFlags_SuppressDoc: return "SuppressDoc";
    case SettingsFlags_CommonTemplate: return "CommonTemplate";
    case SettingsFlags_NonPersistent: return "NonPersistent";
    case SettingsFlags_RequiresReload: return "RequiresReload";
    case SettingsFlags_RequiresRestart: return "RequiresRestart";
    default: return "";
  }
}

struct EnumValueT : public flatbuffers::NativeTable {
  typedef EnumValue TableType;
  std::string Name;
  std::string Description;
  std::string Value;
  EnumValueT() {
  }
};

struct EnumValue FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef EnumValueT NativeTableType;
  typedef EnumValueBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_DESCRIPTION = 6,
    VT_VALUE = 8
  };
  const flatbuffers::String *Name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::String *Description() const {
    return GetPointer<const flatbuffers::String *>(VT_DESCRIPTION);
  }
  const flatbuffers::String *Value() const {
    return GetPointer<const flatbuffers::String *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(Name()) &&
           VerifyOffset(verifier, VT_DESCRIPTION) &&
           verifier.VerifyString(Description()) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyString(Value()) &&
           verifier.EndTable();
  }
  EnumValueT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(EnumValueT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<EnumValue> Pack(flatbuffers::FlatBufferBuilder &_fbb, const EnumValueT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct EnumValueBuilder {
  typedef EnumValue Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_Name(flatbuffers::Offset<flatbuffers::String> Name) {
    fbb_.AddOffset(EnumValue::VT_NAME, Name);
  }
  void add_Description(flatbuffers::Offset<flatbuffers::String> Description) {
    fbb_.AddOffset(EnumValue::VT_DESCRIPTION, Description);
  }
  void add_Value(flatbuffers::Offset<flatbuffers::String> Value) {
    fbb_.AddOffset(EnumValue::VT_VALUE, Value);
  }
  explicit EnumValueBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EnumValueBuilder &operator=(const EnumValueBuilder &);
  flatbuffers::Offset<EnumValue> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EnumValue>(end);
    return o;
  }
};

inline flatbuffers::Offset<EnumValue> CreateEnumValue(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> Name = 0,
    flatbuffers::Offset<flatbuffers::String> Description = 0,
    flatbuffers::Offset<flatbuffers::String> Value = 0) {
  EnumValueBuilder builder_(_fbb);
  builder_.add_Value(Value);
  builder_.add_Description(Description);
  builder_.add_Name(Name);
  return builder_.Finish();
}

inline flatbuffers::Offset<EnumValue> CreateEnumValueDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *Name = nullptr,
    const char *Description = nullptr,
    const char *Value = nullptr) {
  auto Name__ = Name ? _fbb.CreateString(Name) : 0;
  auto Description__ = Description ? _fbb.CreateString(Description) : 0;
  auto Value__ = Value ? _fbb.CreateString(Value) : 0;
  return NymaTypes::CreateEnumValue(
      _fbb,
      Name__,
      Description__,
      Value__);
}

flatbuffers::Offset<EnumValue> CreateEnumValue(flatbuffers::FlatBufferBuilder &_fbb, const EnumValueT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SettingT : public flatbuffers::NativeTable {
  typedef Setting TableType;
  std::string Name;
  std::string Description;
  std::string SettingsKey;
  std::string DefaultValue;
  std::string Min;
  std::string Max;
  NymaTypes::SettingsFlags Flags;
  NymaTypes::SettingType Type;
  std::vector<std::unique_ptr<NymaTypes::EnumValueT>> SettingEnums;
  SettingT()
      : Flags(static_cast<NymaTypes::SettingsFlags>(0)),
        Type(NymaTypes::SettingType_Int) {
  }
};

struct Setting FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SettingT NativeTableType;
  typedef SettingBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_DESCRIPTION = 6,
    VT_SETTINGSKEY = 8,
    VT_DEFAULTVALUE = 10,
    VT_MIN = 12,
    VT_MAX = 14,
    VT_FLAGS = 16,
    VT_TYPE = 18,
    VT_SETTINGENUMS = 20
  };
  const flatbuffers::String *Name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::String *Description() const {
    return GetPointer<const flatbuffers::String *>(VT_DESCRIPTION);
  }
  const flatbuffers::String *SettingsKey() const {
    return GetPointer<const flatbuffers::String *>(VT_SETTINGSKEY);
  }
  const flatbuffers::String *DefaultValue() const {
    return GetPointer<const flatbuffers::String *>(VT_DEFAULTVALUE);
  }
  const flatbuffers::String *Min() const {
    return GetPointer<const flatbuffers::String *>(VT_MIN);
  }
  const flatbuffers::String *Max() const {
    return GetPointer<const flatbuffers::String *>(VT_MAX);
  }
  NymaTypes::SettingsFlags Flags() const {
    return static_cast<NymaTypes::SettingsFlags>(GetField<uint32_t>(VT_FLAGS, 0));
  }
  NymaTypes::SettingType Type() const {
    return static_cast<NymaTypes::SettingType>(GetField<int32_t>(VT_TYPE, 0));
  }
  const flatbuffers::Vector<flatbuffers::Offset<NymaTypes::EnumValue>> *SettingEnums() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<NymaTypes::EnumValue>> *>(VT_SETTINGENUMS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(Name()) &&
           VerifyOffset(verifier, VT_DESCRIPTION) &&
           verifier.VerifyString(Description()) &&
           VerifyOffset(verifier, VT_SETTINGSKEY) &&
           verifier.VerifyString(SettingsKey()) &&
           VerifyOffset(verifier, VT_DEFAULTVALUE) &&
           verifier.VerifyString(DefaultValue()) &&
           VerifyOffset(verifier, VT_MIN) &&
           verifier.VerifyString(Min()) &&
           VerifyOffset(verifier, VT_MAX) &&
           verifier.VerifyString(Max()) &&
           VerifyField<uint32_t>(verifier, VT_FLAGS) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_SETTINGENUMS) &&
           verifier.VerifyVector(SettingEnums()) &&
           verifier.VerifyVectorOfTables(SettingEnums()) &&
           verifier.EndTable();
  }
  SettingT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SettingT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Setting> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SettingT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SettingBuilder {
  typedef Setting Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_Name(flatbuffers::Offset<flatbuffers::String> Name) {
    fbb_.AddOffset(Setting::VT_NAME, Name);
  }
  void add_Description(flatbuffers::Offset<flatbuffers::String> Description) {
    fbb_.AddOffset(Setting::VT_DESCRIPTION, Description);
  }
  void add_SettingsKey(flatbuffers::Offset<flatbuffers::String> SettingsKey) {
    fbb_.AddOffset(Setting::VT_SETTINGSKEY, SettingsKey);
  }
  void add_DefaultValue(flatbuffers::Offset<flatbuffers::String> DefaultValue) {
    fbb_.AddOffset(Setting::VT_DEFAULTVALUE, DefaultValue);
  }
  void add_Min(flatbuffers::Offset<flatbuffers::String> Min) {
    fbb_.AddOffset(Setting::VT_MIN, Min);
  }
  void add_Max(flatbuffers::Offset<flatbuffers::String> Max) {
    fbb_.AddOffset(Setting::VT_MAX, Max);
  }
  void add_Flags(NymaTypes::SettingsFlags Flags) {
    fbb_.AddElement<uint32_t>(Setting::VT_FLAGS, static_cast<uint32_t>(Flags), 0);
  }
  void add_Type(NymaTypes::SettingType Type) {
    fbb_.AddElement<int32_t>(Setting::VT_TYPE, static_cast<int32_t>(Type), 0);
  }
  void add_SettingEnums(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<NymaTypes::EnumValue>>> SettingEnums) {
    fbb_.AddOffset(Setting::VT_SETTINGENUMS, SettingEnums);
  }
  explicit SettingBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SettingBuilder &operator=(const SettingBuilder &);
  flatbuffers::Offset<Setting> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Setting>(end);
    return o;
  }
};

inline flatbuffers::Offset<Setting> CreateSetting(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> Name = 0,
    flatbuffers::Offset<flatbuffers::String> Description = 0,
    flatbuffers::Offset<flatbuffers::String> SettingsKey = 0,
    flatbuffers::Offset<flatbuffers::String> DefaultValue = 0,
    flatbuffers::Offset<flatbuffers::String> Min = 0,
    flatbuffers::Offset<flatbuffers::String> Max = 0,
    NymaTypes::SettingsFlags Flags = static_cast<NymaTypes::SettingsFlags>(0),
    NymaTypes::SettingType Type = NymaTypes::SettingType_Int,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<NymaTypes::EnumValue>>> SettingEnums = 0) {
  SettingBuilder builder_(_fbb);
  builder_.add_SettingEnums(SettingEnums);
  builder_.add_Type(Type);
  builder_.add_Flags(Flags);
  builder_.add_Max(Max);
  builder_.add_Min(Min);
  builder_.add_DefaultValue(DefaultValue);
  builder_.add_SettingsKey(SettingsKey);
  builder_.add_Description(Description);
  builder_.add_Name(Name);
  return builder_.Finish();
}

inline flatbuffers::Offset<Setting> CreateSettingDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *Name = nullptr,
    const char *Description = nullptr,
    const char *SettingsKey = nullptr,
    const char *DefaultValue = nullptr,
    const char *Min = nullptr,
    const char *Max = nullptr,
    NymaTypes::SettingsFlags Flags = static_cast<NymaTypes::SettingsFlags>(0),
    NymaTypes::SettingType Type = NymaTypes::SettingType_Int,
    const std::vector<flatbuffers::Offset<NymaTypes::EnumValue>> *SettingEnums = nullptr) {
  auto Name__ = Name ? _fbb.CreateString(Name) : 0;
  auto Description__ = Description ? _fbb.CreateString(Description) : 0;
  auto SettingsKey__ = SettingsKey ? _fbb.CreateString(SettingsKey) : 0;
  auto DefaultValue__ = DefaultValue ? _fbb.CreateString(DefaultValue) : 0;
  auto Min__ = Min ? _fbb.CreateString(Min) : 0;
  auto Max__ = Max ? _fbb.CreateString(Max) : 0;
  auto SettingEnums__ = SettingEnums ? _fbb.CreateVector<flatbuffers::Offset<NymaTypes::EnumValue>>(*SettingEnums) : 0;
  return NymaTypes::CreateSetting(
      _fbb,
      Name__,
      Description__,
      SettingsKey__,
      DefaultValue__,
      Min__,
      Max__,
      Flags,
      Type,
      SettingEnums__);
}

flatbuffers::Offset<Setting> CreateSetting(flatbuffers::FlatBufferBuilder &_fbb, const SettingT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SettingsT : public flatbuffers::NativeTable {
  typedef Settings TableType;
  std::vector<std::unique_ptr<NymaTypes::SettingT>> Values;
  SettingsT() {
  }
};

struct Settings FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SettingsT NativeTableType;
  typedef SettingsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUES = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<NymaTypes::Setting>> *Values() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<NymaTypes::Setting>> *>(VT_VALUES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VALUES) &&
           verifier.VerifyVector(Values()) &&
           verifier.VerifyVectorOfTables(Values()) &&
           verifier.EndTable();
  }
  SettingsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SettingsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Settings> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SettingsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SettingsBuilder {
  typedef Settings Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_Values(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<NymaTypes::Setting>>> Values) {
    fbb_.AddOffset(Settings::VT_VALUES, Values);
  }
  explicit SettingsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SettingsBuilder &operator=(const SettingsBuilder &);
  flatbuffers::Offset<Settings> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Settings>(end);
    return o;
  }
};

inline flatbuffers::Offset<Settings> CreateSettings(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<NymaTypes::Setting>>> Values = 0) {
  SettingsBuilder builder_(_fbb);
  builder_.add_Values(Values);
  return builder_.Finish();
}

inline flatbuffers::Offset<Settings> CreateSettingsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<NymaTypes::Setting>> *Values = nullptr) {
  auto Values__ = Values ? _fbb.CreateVector<flatbuffers::Offset<NymaTypes::Setting>>(*Values) : 0;
  return NymaTypes::CreateSettings(
      _fbb,
      Values__);
}

flatbuffers::Offset<Settings> CreateSettings(flatbuffers::FlatBufferBuilder &_fbb, const SettingsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline EnumValueT *EnumValue::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<NymaTypes::EnumValueT> _o = std::unique_ptr<NymaTypes::EnumValueT>(new EnumValueT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void EnumValue::UnPackTo(EnumValueT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = Name(); if (_e) _o->Name = _e->str(); }
  { auto _e = Description(); if (_e) _o->Description = _e->str(); }
  { auto _e = Value(); if (_e) _o->Value = _e->str(); }
}

inline flatbuffers::Offset<EnumValue> EnumValue::Pack(flatbuffers::FlatBufferBuilder &_fbb, const EnumValueT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateEnumValue(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<EnumValue> CreateEnumValue(flatbuffers::FlatBufferBuilder &_fbb, const EnumValueT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const EnumValueT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _Name = _o->Name.empty() ? 0 : _fbb.CreateString(_o->Name);
  auto _Description = _o->Description.empty() ? 0 : _fbb.CreateString(_o->Description);
  auto _Value = _o->Value.empty() ? 0 : _fbb.CreateString(_o->Value);
  return NymaTypes::CreateEnumValue(
      _fbb,
      _Name,
      _Description,
      _Value);
}

inline SettingT *Setting::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<NymaTypes::SettingT> _o = std::unique_ptr<NymaTypes::SettingT>(new SettingT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Setting::UnPackTo(SettingT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = Name(); if (_e) _o->Name = _e->str(); }
  { auto _e = Description(); if (_e) _o->Description = _e->str(); }
  { auto _e = SettingsKey(); if (_e) _o->SettingsKey = _e->str(); }
  { auto _e = DefaultValue(); if (_e) _o->DefaultValue = _e->str(); }
  { auto _e = Min(); if (_e) _o->Min = _e->str(); }
  { auto _e = Max(); if (_e) _o->Max = _e->str(); }
  { auto _e = Flags(); _o->Flags = _e; }
  { auto _e = Type(); _o->Type = _e; }
  { auto _e = SettingEnums(); if (_e) { _o->SettingEnums.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->SettingEnums[_i] = std::unique_ptr<NymaTypes::EnumValueT>(_e->Get(_i)->UnPack(_resolver)); } } }
}

inline flatbuffers::Offset<Setting> Setting::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SettingT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSetting(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Setting> CreateSetting(flatbuffers::FlatBufferBuilder &_fbb, const SettingT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SettingT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _Name = _o->Name.empty() ? 0 : _fbb.CreateString(_o->Name);
  auto _Description = _o->Description.empty() ? 0 : _fbb.CreateString(_o->Description);
  auto _SettingsKey = _o->SettingsKey.empty() ? 0 : _fbb.CreateString(_o->SettingsKey);
  auto _DefaultValue = _o->DefaultValue.empty() ? 0 : _fbb.CreateString(_o->DefaultValue);
  auto _Min = _o->Min.empty() ? 0 : _fbb.CreateString(_o->Min);
  auto _Max = _o->Max.empty() ? 0 : _fbb.CreateString(_o->Max);
  auto _Flags = _o->Flags;
  auto _Type = _o->Type;
  auto _SettingEnums = _o->SettingEnums.size() ? _fbb.CreateVector<flatbuffers::Offset<NymaTypes::EnumValue>> (_o->SettingEnums.size(), [](size_t i, _VectorArgs *__va) { return CreateEnumValue(*__va->__fbb, __va->__o->SettingEnums[i].get(), __va->__rehasher); }, &_va ) : 0;
  return NymaTypes::CreateSetting(
      _fbb,
      _Name,
      _Description,
      _SettingsKey,
      _DefaultValue,
      _Min,
      _Max,
      _Flags,
      _Type,
      _SettingEnums);
}

inline SettingsT *Settings::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<NymaTypes::SettingsT> _o = std::unique_ptr<NymaTypes::SettingsT>(new SettingsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Settings::UnPackTo(SettingsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = Values(); if (_e) { _o->Values.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->Values[_i] = std::unique_ptr<NymaTypes::SettingT>(_e->Get(_i)->UnPack(_resolver)); } } }
}

inline flatbuffers::Offset<Settings> Settings::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SettingsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSettings(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Settings> CreateSettings(flatbuffers::FlatBufferBuilder &_fbb, const SettingsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SettingsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _Values = _o->Values.size() ? _fbb.CreateVector<flatbuffers::Offset<NymaTypes::Setting>> (_o->Values.size(), [](size_t i, _VectorArgs *__va) { return CreateSetting(*__va->__fbb, __va->__o->Values[i].get(), __va->__rehasher); }, &_va ) : 0;
  return NymaTypes::CreateSettings(
      _fbb,
      _Values);
}

}  // namespace NymaTypes

#endif  // FLATBUFFERS_GENERATED_NYMATYPES_NYMATYPES_H_
